<!doctype html>
<html lang="en">
    <head>
        <title>Procedural Water</title>
        <meta charset="utf-8">
         <style>
        body{
            margin: 0px;
            padding: 0px;
            overflow: hidden;
        }

        #showWireframe_btn{
			z-index: 1;
			position: absolute;
			font-size: 20px;
			font-style: bold;
			color: white;
		    margin-left: auto;
		    margin-right: auto;
			padding: 10px;
			margin: 10px;
		    width: 140px;
			height: 80px;
			background: rgba(0,0,0,0.9);
			opacity: 0.6;
			border: 2px solid white;
			border-radius: 8px;
			color: white;
			outline: none;
			box-shadow: 3px 3px 3px rgba(0, 0, 0, 0.5);
			top: 0px;
			left: 0px;

}

    </style>
    </head>

    <body>
        <div id="container"></div>
		<button id="showWireframe_btn" onclick="showWireframe()">Wireframe</button>

    </body>

    <script src="js/three.min.js"></script>
	<script src="js/OrbitControls.js"></script>

    

    <script type="text/javascript" id="mainCode">
		    var container, 
		    renderer, 
		    scene, 
		    camera, 
		    mesh, 
		    start = Date.now(),
		    fov = 30
		    wireframe = false;

		    var cameraPos = new THREE.Vector3(0);


		window.addEventListener( 'load', function() {

		    // grab the container from the DOM
		    container = document.getElementById( "container" );

		     // create the renderer and attach it to the DOM
		    renderer = new THREE.WebGLRenderer();
		    renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor ( 0xB3EAFF, 1 );
			renderer.setClearColor ( 0x222225, 1 );

		    
		    container.appendChild( renderer.domElement );
		    
		    // create a scene
		    scene = new THREE.Scene();

		    // create a camera the size of the browser window
		    // and place it 100 units away, looking towards the center of the scene
			camera = new THREE.PerspectiveCamera( 60, window.innerWidth/window.innerHeight, 0.1, 10000 );
		    
		    camera.position.z = 100;

		    //camera.target = new THREE.Vector3( 0, 0, 0 );

			
		    

		    scene.add( camera );

		    // create a wireframe material		
		    material = new THREE.ShaderMaterial( {

			    uniforms: { 
			
			        time: { // float initialized to 0
			            type: "f", 
			            value: 0.0 
			        },
			        cameraPos: { // float initialized to 0
			            type: "v3", 
			            value: new THREE.Vector3(1,1,1)
			        },
			        lightPos: { // float initialized to 0
			            type: "v3", 
			            value: new THREE.Vector3(1,100,1000)
			        }


			    },
			    vertexShader: document.getElementById( 'vertexShader' ).textContent,
			   fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
			   fog: true
			    
			} );

			console.log(material);

	

		    var geometry2 = new THREE.SphereGeometry( 5, 32, 32 );
			var sphere = new THREE.Mesh( geometry2, material );
			scene.add( sphere )
				sphere.translateY(30);


			loader = new THREE.JSONLoader();
			loader.load("ko2.js", 
			function(geometry) {
				object = new THREE.Mesh(geometry, material);
				object.name = 'ko';
				scene.add(object);
				object.scale.set(50,50,50);
			});





		    controls = new THREE.OrbitControls( camera, renderer.domElement );
			//controls.addEventListener( 'change', render ); // add this only if there is no animation loop (requestAnimationFrame)
			controls.enableDamping = true;
			controls.dampingFactor = 0.25;
			controls.enableZoom = true;
			controls.enablePan = false;
			controls.zoomSpeed = 0.9;
			controls.panSpeed = 0;
			controls.rotateSpeed = 0.1;		
	


		    

		    render();

		} );

		window.addEventListener( 'resize', onWindowResize, false );

		function onWindowResize() {

			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}



		function render() {

			scene.updateMatrixWorld();
			cameraPos.setFromMatrixPosition( camera.matrixWorld );

		    material.uniforms[ 'time' ].value = .00025 * ( Date.now() - start );
		    material.uniforms[ 'cameraPos' ].value = cameraPos;
		    renderer.render( scene, camera );
		    requestAnimationFrame( render );
		    
		}

		function showWireframe(){
			if(!wireframe){
				material.wireframe = true; 
				wireframe = true;
			}
			else{
				material.wireframe = false; 
				wireframe = false;
			}

		}
    </script>

    <!--NEW SHADERS-->
    <script type="x-shader/x-vertex" id="vertexShader">
		varying vec3 vNormal;
		varying vec3 vPosition;


void main() {

  // set the vNormal value with
  // the attribute value passed
  // in by Three.js
  vNormal = normal;
  vPosition = normal;

  gl_Position = projectionMatrix *
                modelViewMatrix *
                vec4(position, 1.0);
}
    </script>

    <script type="x-shader/x-vertex" id="fragmentShader">
	varying vec3 vNormal;
	varying vec3 vPosition;

	uniform vec3 cameraPos;


	void main() {

		// calc the dot product and clamp
		// 0 -> 1 rather than -1 -> 1
		vec3 light = vec3(0.5, 0.2, 1.0);

		// ensure it's normalized
		light = normalize(light);

		// calculate the dot product of
		// the light to the vertex normal
		float dProd = max(0.0,
		                dot(vNormal, light));

		vec3 r = normalize(cameraPos - vPosition);

		float steepAngle = dot(r, vNormal);
		// feed into our frag colour
		gl_FragColor = vec4(steepAngle);  // A

		if(steepAngle < 0.9){
		gl_FragColor = vec4(0.3,0.3,0.3,0.4);  // A

		}

	}

    </script>



</html>